#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import os from 'os'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`)
}

// Parse command line arguments
const args = process.argv.slice(2)
let projectPath = process.cwd()
let outputDir = '.'

for (let i = 0; i < args.length; i++) {
  if (args[i] === '-p' || args[i] === '--project') {
    projectPath = path.resolve(args[i + 1])
    i++
  } else if (args[i] === '-o' || args[i] === '--output') {
    outputDir = path.resolve(args[i + 1])
    i++
  }
}

async function generateTypes() {
  try {
    // Check if env.config.ts or env.config.js exists
    const configTsPath = path.join(projectPath, 'env.config.ts')
    const configJsPath = path.join(projectPath, 'env.config.js')
    
    let configPath = null
    if (fs.existsSync(configTsPath)) {
      configPath = configTsPath
    } else if (fs.existsSync(configJsPath)) {
      configPath = configJsPath
    } else {
      log('âŒ No env.config.ts or env.config.js found in project', colors.red)
      log('Run "env-manager init" first to create configuration', colors.yellow)
      process.exit(1)
    }
    
    // Use dynamic import with jiti for TypeScript support
    const { createJiti } = await import('jiti')
    const jiti = createJiti(import.meta.url, { 
      interopDefault: true,
      cache: false,
      requireCache: false
    })
    
    // Import the project config
    const configModule = await jiti.import(configPath)
    const projectConfig = configModule.default || configModule
    
    // Try to load existing variables from database
    let variables = []
    const projectName = path.basename(projectPath)
    const dbPath = path.join(os.homedir(), '.env-manager-data', `${projectName}.db`)
    
    if (fs.existsSync(dbPath)) {
      try {
        // Try to use better-sqlite3 directly
        const Database = await import('better-sqlite3').then(m => m.default)
        const db = new Database(dbPath, { readonly: true })
        
        // Get variables from database
        const stmt = db.prepare('SELECT * FROM variables WHERE deleted = 0')
        variables = stmt.all() || []
        db.close()
      } catch (error) {
        log('âš ï¸  Could not load existing variables from database', colors.yellow)
      }
    }
    
    // Generate TypeScript types
    const types = generateTypeDefinitions(projectConfig, variables)
    const globalTypes = generateGlobalTypeDefinitions(projectConfig, variables)
    
    // Write the generated types to files
    const typesPath = path.join(outputDir, 'env.types.ts')
    const globalTypesPath = path.join(outputDir, 'env.d.ts')
    
    fs.writeFileSync(typesPath, types)
    fs.writeFileSync(globalTypesPath, globalTypes)
    
    log('âœ… TypeScript types generated successfully!', colors.green)
    log(`   ðŸ“„ ${path.relative(process.cwd(), typesPath)}`, colors.blue)
    log(`   ðŸ“„ ${path.relative(process.cwd(), globalTypesPath)}`, colors.blue)
    log('', colors.reset)
    log('Import and use your typed variables:', colors.cyan)
    log('  import { env, clientEnv, serverEnv } from "./env.types"', colors.yellow)
    
  } catch (error) {
    log(`âŒ Failed to generate types: ${error.message}`, colors.red)
    console.error(error)
    process.exit(1)
  }
}

function generateTypeDefinitions(projectConfig, variables) {
  const lines = []
  
  // Header
  lines.push('/**')
  lines.push(' * Auto-generated environment variable types')
  lines.push(' * DO NOT EDIT THIS FILE DIRECTLY')
  lines.push(' * Generated by env-manager')
  lines.push(' */')
  lines.push('')
  
  // Separate variables by type (client vs server)
  const clientVars = []
  const serverVars = []
  
  if (projectConfig.requirements) {
    for (const [groupName, group] of Object.entries(projectConfig.requirements)) {
      if (group.variables) {
        for (const varConfig of group.variables) {
          // Detect client variables (common patterns)
          const isClient = isClientVariable(varConfig.name)
          
          if (isClient) {
            clientVars.push({ config: varConfig, group: groupName })
          } else {
            serverVars.push({ config: varConfig, group: groupName })
          }
        }
      }
    }
  }
  
  // Generate CLIENT variables interface
  lines.push('/**')
  lines.push(' * ðŸŒ CLIENT/PUBLIC Environment Variables')
  lines.push(' * These variables are exposed to the client/browser')
  lines.push(' * âš ï¸ DO NOT put sensitive data in these variables!')
  lines.push(' */')
  lines.push('export interface ClientEnvVariables {')
  
  if (clientVars.length > 0) {
    const grouped = groupVariables(clientVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`  // ${groupName}`)
      for (const { config } of vars) {
        const tsType = getTypeScriptType(config)
        const optional = !config.required ? '?' : ''
        if (config.description) {
          lines.push(`  /** ${config.description} */`)
        }
        lines.push(`  ${config.name}${optional}: ${tsType}`)
      }
    }
  } else {
    lines.push('  // No client variables defined')
  }
  
  lines.push('}')
  lines.push('')
  
  // Generate SERVER variables interface
  lines.push('/**')
  lines.push(' * ðŸ”’ SERVER/PRIVATE Environment Variables')
  lines.push(' * These variables are only available on the server')
  lines.push(' * âœ… Safe for sensitive data like API keys, passwords, etc.')
  lines.push(' */')
  lines.push('export interface ServerEnvVariables {')
  
  if (serverVars.length > 0) {
    const grouped = groupVariables(serverVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`  // ${groupName}`)
      for (const { config } of vars) {
        const tsType = getTypeScriptType(config)
        const optional = !config.required ? '?' : ''
        if (config.description) {
          lines.push(`  /** ${config.description} */`)
        }
        lines.push(`  ${config.name}${optional}: ${tsType}`)
      }
    }
  } else {
    lines.push('  // No server variables defined')
  }
  
  lines.push('}')
  lines.push('')
  
  // Generate combined interface
  lines.push('/**')
  lines.push(' * All Environment Variables (Client + Server)')
  lines.push(' */')
  lines.push('export interface EnvVariables extends ClientEnvVariables, ServerEnvVariables {}')
  lines.push('')
  
  // Generate runtime objects
  lines.push('/**')
  lines.push(' * ðŸŒ CLIENT Environment Variables (Runtime)')
  lines.push(' */')
  lines.push('export const clientEnv = {')
  
  if (clientVars.length > 0) {
    const grouped = groupVariables(clientVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`  // ${groupName}`)
      for (const { config } of vars) {
        lines.push(`  ${config.name}: process.env.${config.name} as ${getTypeScriptType(config)},`)
      }
    }
  }
  
  lines.push('} as const satisfies ClientEnvVariables')
  lines.push('')
  
  lines.push('/**')
  lines.push(' * ðŸ”’ SERVER Environment Variables (Runtime)')
  lines.push(' */')
  lines.push('export const serverEnv = {')
  
  if (serverVars.length > 0) {
    const grouped = groupVariables(serverVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`  // ${groupName}`)
      for (const { config } of vars) {
        lines.push(`  ${config.name}: process.env.${config.name} as ${getTypeScriptType(config)},`)
      }
    }
  }
  
  lines.push('} as const satisfies ServerEnvVariables')
  lines.push('')
  
  lines.push('/**')
  lines.push(' * All Environment Variables (Runtime)')
  lines.push(' */')
  lines.push('export const env = {')
  lines.push('  ...clientEnv,')
  lines.push('  ...serverEnv,')
  lines.push('} as const satisfies EnvVariables')
  lines.push('')
  
  // Generate type-safe getter
  lines.push('/**')
  lines.push(' * Type-safe environment variable getter')
  lines.push(' */')
  lines.push('export function getEnv<K extends keyof EnvVariables>(key: K): EnvVariables[K] {')
  lines.push('  return env[key]')
  lines.push('}')
  lines.push('')
  
  // Generate validation functions
  lines.push('/**')
  lines.push(' * Validate CLIENT environment variables')
  lines.push(' */')
  lines.push('export function validateClientEnv(): void {')
  lines.push('  const missing: string[] = []')
  
  for (const { config } of clientVars) {
    if (config.required) {
      lines.push(`  if (!process.env.${config.name}) {`)
      lines.push(`    missing.push('${config.name}')`)
      lines.push('  }')
    }
  }
  
  lines.push('  if (missing.length > 0) {')
  lines.push('    throw new Error(`Missing required CLIENT environment variables: ${missing.join(", ")}`)') 
  lines.push('  }')
  lines.push('}')
  lines.push('')
  
  lines.push('/**')
  lines.push(' * Validate SERVER environment variables')
  lines.push(' */')
  lines.push('export function validateServerEnv(): void {')
  lines.push('  const missing: string[] = []')
  
  for (const { config } of serverVars) {
    if (config.required) {
      lines.push(`  if (!process.env.${config.name}) {`)
      lines.push(`    missing.push('${config.name}')`)
      lines.push('  }')
    }
  }
  
  lines.push('  if (missing.length > 0) {')
  lines.push('    throw new Error(`Missing required SERVER environment variables: ${missing.join(", ")}`)') 
  lines.push('  }')
  lines.push('}')
  lines.push('')
  
  lines.push('/**')
  lines.push(' * Validate ALL environment variables')
  lines.push(' */')
  lines.push('export function validateEnv(): void {')
  lines.push('  validateClientEnv()')
  lines.push('  validateServerEnv()')
  lines.push('}')
  
  return lines.join('\n')
}

function generateGlobalTypeDefinitions(projectConfig, variables) {
  const lines = []
  
  // Separate variables by type
  const clientVars = []
  const serverVars = []
  
  if (projectConfig.requirements) {
    for (const [groupName, group] of Object.entries(projectConfig.requirements)) {
      if (group.variables) {
        for (const varConfig of group.variables) {
          const isClient = isClientVariable(varConfig.name)
          
          if (isClient) {
            clientVars.push({ config: varConfig, group: groupName })
          } else {
            serverVars.push({ config: varConfig, group: groupName })
          }
        }
      }
    }
  }
  
  lines.push('/**')
  lines.push(' * Global environment variable type declarations')
  lines.push(' * Auto-generated by env-manager')
  lines.push(' */')
  lines.push('')
  lines.push('declare global {')
  lines.push('  namespace NodeJS {')
  lines.push('    interface ProcessEnv {')
  
  // Add CLIENT variables
  if (clientVars.length > 0) {
    lines.push('      // ðŸŒ CLIENT/PUBLIC Environment Variables')
    const grouped = groupVariables(clientVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`      // ${groupName}`)
      for (const { config } of vars) {
        const tsType = getTypeScriptType(config)
        const optional = !config.required ? '?' : ''
        if (config.description) {
          lines.push(`      /** ðŸŒ CLIENT: ${config.description} */`)
        }
        lines.push(`      ${config.name}${optional}: ${tsType}`)
      }
    }
    lines.push('')
  }
  
  // Add SERVER variables
  if (serverVars.length > 0) {
    lines.push('      // ðŸ”’ SERVER/PRIVATE Environment Variables')
    const grouped = groupVariables(serverVars)
    for (const [groupName, vars] of Object.entries(grouped)) {
      lines.push(`      // ${groupName}`)
      for (const { config } of vars) {
        const tsType = getTypeScriptType(config)
        const optional = !config.required ? '?' : ''
        if (config.description) {
          lines.push(`      /** ðŸ”’ SERVER: ${config.description} */`)
        }
        lines.push(`      ${config.name}${optional}: ${tsType}`)
      }
    }
  }
  
  lines.push('    }')
  lines.push('  }')
  lines.push('}')
  lines.push('')
  lines.push('export {}')
  
  return lines.join('\n')
}

function getTypeScriptType(varConfig) {
  switch (varConfig.type) {
    case 'number':
    case 'port':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'json':
      return 'Record<string, any>'
    case 'url':
    case 'email':
    case 'path':
    case 'string':
    default:
      return 'string'
  }
}

function isClientVariable(name) {
  const clientPatterns = [
    /^NEXT_PUBLIC_/i,
    /^VITE_/i,
    /^REACT_APP_/i,
    /^GATSBY_/i,
    /^NUXT_PUBLIC_/i,
    /^PUBLIC_/i,
    /^EXPO_PUBLIC_/i,
    /^ASTRO_PUBLIC_/i,
  ]
  
  return clientPatterns.some(pattern => pattern.test(name))
}

function groupVariables(vars) {
  const grouped = {}
  
  for (const variable of vars) {
    if (!grouped[variable.group]) {
      grouped[variable.group] = []
    }
    grouped[variable.group].push(variable)
  }
  
  return grouped
}

// Run the generator
generateTypes()