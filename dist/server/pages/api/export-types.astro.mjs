import { g as getDatabase } from '../../chunks/session_DKC9ty2U.mjs';
import fs from 'fs/promises';
import path from 'path';
export { renderers } from '../../renderers.mjs';

class TypeExporter {
  constructor(projectConfig, variables) {
    this.projectConfig = projectConfig;
    this.variables = variables;
  }
  /**
   * Generate TypeScript types for environment variables
   */
  generateTypes() {
    const lines = [];
    lines.push("/**");
    lines.push(" * Auto-generated environment variable types");
    lines.push(" * DO NOT EDIT THIS FILE DIRECTLY");
    lines.push(" * Generated by env-manager");
    lines.push(" */");
    lines.push("");
    const clientVars = [];
    const serverVars = [];
    for (const [groupName, group] of Object.entries(this.projectConfig.requirements)) {
      for (const varConfig of group.variables) {
        const isClient = this.isClientVariable(varConfig.name);
        if (isClient) {
          clientVars.push({ config: varConfig, group: groupName });
        } else {
          serverVars.push({ config: varConfig, group: groupName });
        }
      }
    }
    lines.push("/**");
    lines.push(" * ðŸŒ CLIENT/PUBLIC Environment Variables");
    lines.push(" * These variables are exposed to the client/browser");
    lines.push(" * âš ï¸ DO NOT put sensitive data in these variables!");
    lines.push(" */");
    lines.push("export interface ClientEnvVariables {");
    if (clientVars.length > 0) {
      const groupedClient = this.groupVariables(clientVars);
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`  // ${groupName}`);
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config);
          const optional = !config.required ? "?" : "";
          if (config.description) {
            lines.push(`  /** ${config.description} */`);
          }
          lines.push(`  ${config.name}${optional}: ${tsType}`);
        }
      }
    } else {
      lines.push("  // No client variables defined");
    }
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * ðŸ”’ SERVER/PRIVATE Environment Variables");
    lines.push(" * These variables are only available on the server");
    lines.push(" * âœ… Safe for sensitive data like API keys, passwords, etc.");
    lines.push(" */");
    lines.push("export interface ServerEnvVariables {");
    if (serverVars.length > 0) {
      const groupedServer = this.groupVariables(serverVars);
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`  // ${groupName}`);
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config);
          const optional = !config.required ? "?" : "";
          if (config.description) {
            lines.push(`  /** ${config.description} */`);
          }
          lines.push(`  ${config.name}${optional}: ${tsType}`);
        }
      }
    } else {
      lines.push("  // No server variables defined");
    }
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * All Environment Variables (Client + Server)");
    lines.push(" */");
    lines.push("export interface EnvVariables extends ClientEnvVariables, ServerEnvVariables {}");
    lines.push("");
    lines.push("/**");
    lines.push(" * ðŸŒ CLIENT Environment Variables (Runtime)");
    lines.push(" * Access client/public variables in your application");
    lines.push(" */");
    lines.push("export const clientEnv = {");
    new Map(this.variables.map((v) => [v.name, v]));
    if (clientVars.length > 0) {
      const groupedClient = this.groupVariables(clientVars);
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`  // ${groupName}`);
        for (const { config } of vars) {
          lines.push(`  ${config.name}: process.env.${config.name} as ${this.getTypeScriptType(config)},`);
        }
      }
    }
    lines.push("} as const satisfies ClientEnvVariables");
    lines.push("");
    lines.push("/**");
    lines.push(" * ðŸ”’ SERVER Environment Variables (Runtime)");
    lines.push(" * Access server/private variables in your application");
    lines.push(" * âš ï¸ Never expose these to the client!");
    lines.push(" */");
    lines.push("export const serverEnv = {");
    if (serverVars.length > 0) {
      const groupedServer = this.groupVariables(serverVars);
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`  // ${groupName}`);
        for (const { config } of vars) {
          lines.push(`  ${config.name}: process.env.${config.name} as ${this.getTypeScriptType(config)},`);
        }
      }
    }
    lines.push("} as const satisfies ServerEnvVariables");
    lines.push("");
    lines.push("/**");
    lines.push(" * All Environment Variables (Runtime)");
    lines.push(" * Combines both client and server variables");
    lines.push(" */");
    lines.push("export const env = {");
    lines.push("  ...clientEnv,");
    lines.push("  ...serverEnv,");
    lines.push("} as const satisfies EnvVariables");
    lines.push("");
    lines.push("/**");
    lines.push(" * Type-safe environment variable getter");
    lines.push(" * @param key - The environment variable key");
    lines.push(" * @returns The typed environment variable value");
    lines.push(" */");
    lines.push("export function getEnv<K extends keyof EnvVariables>(key: K): EnvVariables[K] {");
    lines.push("  return env[key]");
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * Validate CLIENT environment variables");
    lines.push(" * @throws Error if required client variables are missing");
    lines.push(" */");
    lines.push("export function validateClientEnv(): void {");
    lines.push("  const missing: string[] = []");
    lines.push("");
    for (const { config } of clientVars) {
      if (config.required) {
        lines.push(`  if (!process.env.${config.name}) {`);
        lines.push(`    missing.push('${config.name}')`);
        lines.push("  }");
      }
    }
    lines.push("");
    lines.push("  if (missing.length > 0) {");
    lines.push("    throw new Error(`Missing required CLIENT environment variables: ${missing.join(', ')}`)");
    lines.push("  }");
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * Validate SERVER environment variables");
    lines.push(" * @throws Error if required server variables are missing");
    lines.push(" */");
    lines.push("export function validateServerEnv(): void {");
    lines.push("  const missing: string[] = []");
    lines.push("");
    for (const { config } of serverVars) {
      if (config.required) {
        lines.push(`  if (!process.env.${config.name}) {`);
        lines.push(`    missing.push('${config.name}')`);
        lines.push("  }");
      }
    }
    lines.push("");
    lines.push("  if (missing.length > 0) {");
    lines.push("    throw new Error(`Missing required SERVER environment variables: ${missing.join(', ')}`)");
    lines.push("  }");
    lines.push("}");
    lines.push("");
    lines.push("/**");
    lines.push(" * Validate ALL environment variables");
    lines.push(" * @throws Error if any required variables are missing");
    lines.push(" */");
    lines.push("export function validateEnv(): void {");
    lines.push("  validateClientEnv()");
    lines.push("  validateServerEnv()");
    lines.push("}");
    return lines.join("\n");
  }
  /**
   * Generate a .env.d.ts file for global type declarations
   */
  generateGlobalTypes() {
    const lines = [];
    const clientVars = [];
    const serverVars = [];
    for (const [groupName, group] of Object.entries(this.projectConfig.requirements)) {
      for (const varConfig of group.variables) {
        const isClient = this.isClientVariable(varConfig.name);
        if (isClient) {
          clientVars.push({ config: varConfig, group: groupName });
        } else {
          serverVars.push({ config: varConfig, group: groupName });
        }
      }
    }
    lines.push("/**");
    lines.push(" * Global environment variable type declarations");
    lines.push(" * Auto-generated by env-manager");
    lines.push(" */");
    lines.push("");
    lines.push("declare global {");
    lines.push("  namespace NodeJS {");
    lines.push("    interface ProcessEnv {");
    if (clientVars.length > 0) {
      lines.push("      // ========================================");
      lines.push("      // ðŸŒ CLIENT/PUBLIC Environment Variables");
      lines.push("      // âš ï¸ These are exposed to the browser!");
      lines.push("      // ========================================");
      const groupedClient = this.groupVariables(clientVars);
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`      // ${groupName}`);
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config);
          const optional = !config.required ? "?" : "";
          if (config.description) {
            lines.push(`      /** ðŸŒ CLIENT: ${config.description} */`);
          }
          lines.push(`      ${config.name}${optional}: ${tsType}`);
        }
      }
      lines.push("");
    }
    if (serverVars.length > 0) {
      lines.push("      // ========================================");
      lines.push("      // ðŸ”’ SERVER/PRIVATE Environment Variables");
      lines.push("      // âœ… These are safe for sensitive data");
      lines.push("      // ========================================");
      const groupedServer = this.groupVariables(serverVars);
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`      // ${groupName}`);
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config);
          const optional = !config.required ? "?" : "";
          if (config.description) {
            lines.push(`      /** ðŸ”’ SERVER: ${config.description} */`);
          }
          lines.push(`      ${config.name}${optional}: ${tsType}`);
        }
      }
    }
    lines.push("    }");
    lines.push("  }");
    lines.push("}");
    lines.push("");
    lines.push("export {}");
    return lines.join("\n");
  }
  /**
   * Export types to files
   */
  async exportToFiles(outputDir) {
    await fs.mkdir(outputDir, { recursive: true });
    const typesPath = path.join(outputDir, "env.types.ts");
    await fs.writeFile(typesPath, this.generateTypes());
    const globalTypesPath = path.join(outputDir, "env.d.ts");
    await fs.writeFile(globalTypesPath, this.generateGlobalTypes());
  }
  getTypeScriptType(varConfig) {
    switch (varConfig.type) {
      case "number":
        return "number";
      case "boolean":
        return "boolean";
      case "port":
        return "number";
      case "json":
        return "Record<string, any>";
      case "url":
      case "email":
      case "path":
      case "string":
      default:
        return "string";
    }
  }
  formatValue(value, varConfig) {
    switch (varConfig.type) {
      case "number":
      case "port":
        return value || "0";
      case "boolean":
        return value === "true" ? "true" : "false";
      case "json":
        try {
          return JSON.stringify(JSON.parse(value));
        } catch {
          return "{}";
        }
      default:
        return `"${value || ""}"`;
    }
  }
  toPascalCase(str) {
    return str.split(/[-_\s]+/).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
  }
  /**
   * Determine if a variable is a client-side variable based on common patterns
   */
  isClientVariable(name) {
    const clientPatterns = [
      /^NEXT_PUBLIC_/i,
      /^VITE_/i,
      /^REACT_APP_/i,
      /^GATSBY_/i,
      /^NUXT_PUBLIC_/i,
      /^PUBLIC_/i,
      /^EXPO_PUBLIC_/i,
      /^ASTRO_PUBLIC_/i
    ];
    return clientPatterns.some((pattern) => pattern.test(name));
  }
  /**
   * Group variables by their group name
   */
  groupVariables(vars) {
    const grouped = {};
    for (const variable of vars) {
      if (!grouped[variable.group]) {
        grouped[variable.group] = [];
      }
      grouped[variable.group].push(variable);
    }
    return grouped;
  }
}

const GET = async ({ request }) => {
  try {
    const database = getDatabase();
    if (!database.isAuthenticated()) {
      return new Response(JSON.stringify({ error: "Not authenticated" }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const url = new URL(request.url);
    const projectPath = url.searchParams.get("projectPath");
    const format = url.searchParams.get("format") || "typescript";
    const projectRoot = projectPath || process.env.PROJECT_ROOT || path.resolve(process.cwd(), "..");
    const configPath = path.join(projectRoot, "env.config.ts");
    try {
      await fs.access(configPath);
    } catch {
      return new Response(JSON.stringify({
        error: "No env.config.ts found in project root"
      }), {
        status: 404,
        headers: { "Content-Type": "application/json" }
      });
    }
    const configModule = await import(
      /* @vite-ignore */
      configPath
    );
    const projectConfig = configModule.default;
    const variables = database.getAllVariables();
    const exporter = new TypeExporter(projectConfig, variables);
    let content = "";
    let filename = "";
    switch (format) {
      case "global":
        content = exporter.generateGlobalTypes();
        filename = "env.d.ts";
        break;
      case "both":
        const types = exporter.generateTypes();
        const globalTypes = exporter.generateGlobalTypes();
        content = `// ===== env.types.ts =====
${types}

// ===== env.d.ts =====
${globalTypes}`;
        filename = "env-types.ts";
        break;
      case "typescript":
      default:
        content = exporter.generateTypes();
        filename = "env.types.ts";
        break;
    }
    return new Response(JSON.stringify({
      content,
      filename,
      format
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Export types error:", error);
    return new Response(JSON.stringify({
      error: "Failed to export types",
      message: error instanceof Error ? error.message : String(error)
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};
const POST = async ({ request }) => {
  try {
    const database = getDatabase();
    if (!database.isAuthenticated()) {
      return new Response(JSON.stringify({ error: "Not authenticated" }), {
        status: 401,
        headers: { "Content-Type": "application/json" }
      });
    }
    const { projectPath, outputDir } = await request.json();
    const projectRoot = projectPath || process.env.PROJECT_ROOT || path.resolve(process.cwd(), "..");
    const configPath = path.join(projectRoot, "env.config.ts");
    const configModule = await import(
      /* @vite-ignore */
      configPath
    );
    const projectConfig = configModule.default;
    const variables = database.getAllVariables();
    const exporter = new TypeExporter(projectConfig, variables);
    const targetDir = outputDir || path.join(projectRoot, "src", "types");
    await exporter.exportToFiles(targetDir);
    return new Response(JSON.stringify({
      success: true,
      outputDir: targetDir,
      files: ["env.types.ts", "env.d.ts"]
    }), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("Export types error:", error);
    return new Response(JSON.stringify({
      error: "Failed to export types",
      message: error instanceof Error ? error.message : String(error)
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
};

const _page = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  GET,
  POST
}, Symbol.toStringTag, { value: 'Module' }));

const page = () => _page;

export { page };
