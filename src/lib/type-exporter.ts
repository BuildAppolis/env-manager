import type { ProjectConfig, ProjectVariableConfig, DatabaseVariable } from '../types'
import fs from 'fs/promises'
import path from 'path'

export class TypeExporter {
  private projectConfig: ProjectConfig
  private variables: DatabaseVariable[]

  constructor(projectConfig: ProjectConfig, variables: DatabaseVariable[]) {
    this.projectConfig = projectConfig
    this.variables = variables
  }

  /**
   * Generate TypeScript types for environment variables
   */
  generateTypes(): string {
    const lines: string[] = []
    
    // Header
    lines.push('/**')
    lines.push(' * Auto-generated environment variable types')
    lines.push(' * DO NOT EDIT THIS FILE DIRECTLY')
    lines.push(' * Generated by env-manager')
    lines.push(' */')
    lines.push('')
    
    // Separate variables by type (client vs server)
    const clientVars: Array<{ config: ProjectVariableConfig, group: string }> = []
    const serverVars: Array<{ config: ProjectVariableConfig, group: string }> = []
    
    for (const [groupName, group] of Object.entries(this.projectConfig.requirements)) {
      for (const varConfig of group.variables) {
        // Detect client variables (common patterns)
        const isClient = this.isClientVariable(varConfig.name)
        
        if (isClient) {
          clientVars.push({ config: varConfig, group: groupName })
        } else {
          serverVars.push({ config: varConfig, group: groupName })
        }
      }
    }
    
    // Generate CLIENT variables interface
    lines.push('/**')
    lines.push(' * üåê CLIENT/PUBLIC Environment Variables')
    lines.push(' * These variables are exposed to the client/browser')
    lines.push(' * ‚ö†Ô∏è DO NOT put sensitive data in these variables!')
    lines.push(' */')
    lines.push('export interface ClientEnvVariables {')
    
    if (clientVars.length > 0) {
      const groupedClient = this.groupVariables(clientVars)
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`  // ${groupName}`)
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config)
          const optional = !config.required ? '?' : ''
          if (config.description) {
            lines.push(`  /** ${config.description} */`)
          }
          lines.push(`  ${config.name}${optional}: ${tsType}`)
        }
      }
    } else {
      lines.push('  // No client variables defined')
    }
    
    lines.push('}')
    lines.push('')
    
    // Generate SERVER variables interface
    lines.push('/**')
    lines.push(' * üîí SERVER/PRIVATE Environment Variables')
    lines.push(' * These variables are only available on the server')
    lines.push(' * ‚úÖ Safe for sensitive data like API keys, passwords, etc.')
    lines.push(' */')
    lines.push('export interface ServerEnvVariables {')
    
    if (serverVars.length > 0) {
      const groupedServer = this.groupVariables(serverVars)
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`  // ${groupName}`)
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config)
          const optional = !config.required ? '?' : ''
          if (config.description) {
            lines.push(`  /** ${config.description} */`)
          }
          lines.push(`  ${config.name}${optional}: ${tsType}`)
        }
      }
    } else {
      lines.push('  // No server variables defined')
    }
    
    lines.push('}')
    lines.push('')
    
    // Generate combined interface
    lines.push('/**')
    lines.push(' * All Environment Variables (Client + Server)')
    lines.push(' */')
    lines.push('export interface EnvVariables extends ClientEnvVariables, ServerEnvVariables {}')
    lines.push('')
    
    // Generate runtime objects separated by type
    lines.push('/**')
    lines.push(' * üåê CLIENT Environment Variables (Runtime)')
    lines.push(' * Access client/public variables in your application')
    lines.push(' */')
    lines.push('export const clientEnv = {')
    
    const variableMap = new Map(this.variables.map(v => [v.name, v]))
    
    if (clientVars.length > 0) {
      const groupedClient = this.groupVariables(clientVars)
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`  // ${groupName}`)
        for (const { config } of vars) {
          lines.push(`  ${config.name}: process.env.${config.name} as ${this.getTypeScriptType(config)},`)
        }
      }
    }
    
    lines.push('} as const satisfies ClientEnvVariables')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * üîí SERVER Environment Variables (Runtime)')
    lines.push(' * Access server/private variables in your application')
    lines.push(' * ‚ö†Ô∏è Never expose these to the client!')
    lines.push(' */')
    lines.push('export const serverEnv = {')
    
    if (serverVars.length > 0) {
      const groupedServer = this.groupVariables(serverVars)
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`  // ${groupName}`)
        for (const { config } of vars) {
          lines.push(`  ${config.name}: process.env.${config.name} as ${this.getTypeScriptType(config)},`)
        }
      }
    }
    
    lines.push('} as const satisfies ServerEnvVariables')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * All Environment Variables (Runtime)')
    lines.push(' * Combines both client and server variables')
    lines.push(' */')
    lines.push('export const env = {')
    lines.push('  ...clientEnv,')
    lines.push('  ...serverEnv,')
    lines.push('} as const satisfies EnvVariables')
    lines.push('')
    
    // Generate type-safe getter function
    lines.push('/**')
    lines.push(' * Type-safe environment variable getter')
    lines.push(' * @param key - The environment variable key')
    lines.push(' * @returns The typed environment variable value')
    lines.push(' */')
    lines.push('export function getEnv<K extends keyof EnvVariables>(key: K): EnvVariables[K] {')
    lines.push('  return env[key]')
    lines.push('}')
    lines.push('')
    
    // Generate validation functions
    lines.push('/**')
    lines.push(' * Validate CLIENT environment variables')
    lines.push(' * @throws Error if required client variables are missing')
    lines.push(' */')
    lines.push('export function validateClientEnv(): void {')
    lines.push('  const missing: string[] = []')
    lines.push('')
    
    for (const { config } of clientVars) {
      if (config.required) {
        lines.push(`  if (!process.env.${config.name}) {`)
        lines.push(`    missing.push('${config.name}')`)
        lines.push('  }')
      }
    }
    
    lines.push('')
    lines.push('  if (missing.length > 0) {')
    lines.push('    throw new Error(`Missing required CLIENT environment variables: ${missing.join(\', \')}`)') 
    lines.push('  }')
    lines.push('}')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * Validate SERVER environment variables')
    lines.push(' * @throws Error if required server variables are missing')
    lines.push(' */')
    lines.push('export function validateServerEnv(): void {')
    lines.push('  const missing: string[] = []')
    lines.push('')
    
    for (const { config } of serverVars) {
      if (config.required) {
        lines.push(`  if (!process.env.${config.name}) {`)
        lines.push(`    missing.push('${config.name}')`)
        lines.push('  }')
      }
    }
    
    lines.push('')
    lines.push('  if (missing.length > 0) {')
    lines.push('    throw new Error(`Missing required SERVER environment variables: ${missing.join(\', \')}`)') 
    lines.push('  }')
    lines.push('}')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * Validate ALL environment variables')
    lines.push(' * @throws Error if any required variables are missing')
    lines.push(' */')
    lines.push('export function validateEnv(): void {')
    lines.push('  validateClientEnv()')
    lines.push('  validateServerEnv()')
    lines.push('}')
    
    return lines.join('\n')
  }

  /**
   * Generate a .env.d.ts file for global type declarations
   */
  generateGlobalTypes(): string {
    const lines: string[] = []
    
    // Separate variables by type
    const clientVars: Array<{ config: ProjectVariableConfig, group: string }> = []
    const serverVars: Array<{ config: ProjectVariableConfig, group: string }> = []
    
    for (const [groupName, group] of Object.entries(this.projectConfig.requirements)) {
      for (const varConfig of group.variables) {
        const isClient = this.isClientVariable(varConfig.name)
        
        if (isClient) {
          clientVars.push({ config: varConfig, group: groupName })
        } else {
          serverVars.push({ config: varConfig, group: groupName })
        }
      }
    }
    
    lines.push('/**')
    lines.push(' * Global environment variable type declarations')
    lines.push(' * Auto-generated by env-manager')
    lines.push(' */')
    lines.push('')
    lines.push('declare global {')
    lines.push('  namespace NodeJS {')
    lines.push('    interface ProcessEnv {')
    
    // Add CLIENT variables section
    if (clientVars.length > 0) {
      lines.push('      // ========================================')
      lines.push('      // üåê CLIENT/PUBLIC Environment Variables')
      lines.push('      // ‚ö†Ô∏è These are exposed to the browser!')
      lines.push('      // ========================================')
      
      const groupedClient = this.groupVariables(clientVars)
      for (const [groupName, vars] of Object.entries(groupedClient)) {
        lines.push(`      // ${groupName}`)
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config)
          const optional = !config.required ? '?' : ''
          if (config.description) {
            lines.push(`      /** üåê CLIENT: ${config.description} */`)
          }
          lines.push(`      ${config.name}${optional}: ${tsType}`)
        }
      }
      lines.push('')
    }
    
    // Add SERVER variables section
    if (serverVars.length > 0) {
      lines.push('      // ========================================')
      lines.push('      // üîí SERVER/PRIVATE Environment Variables')
      lines.push('      // ‚úÖ These are safe for sensitive data')
      lines.push('      // ========================================')
      
      const groupedServer = this.groupVariables(serverVars)
      for (const [groupName, vars] of Object.entries(groupedServer)) {
        lines.push(`      // ${groupName}`)
        for (const { config } of vars) {
          const tsType = this.getTypeScriptType(config)
          const optional = !config.required ? '?' : ''
          if (config.description) {
            lines.push(`      /** üîí SERVER: ${config.description} */`)
          }
          lines.push(`      ${config.name}${optional}: ${tsType}`)
        }
      }
    }
    
    lines.push('    }')
    lines.push('  }')
    lines.push('}')
    lines.push('')
    lines.push('export {}')
    
    return lines.join('\n')
  }

  /**
   * Export types to files
   */
  async exportToFiles(outputDir: string): Promise<void> {
    await fs.mkdir(outputDir, { recursive: true })
    
    // Write main types file
    const typesPath = path.join(outputDir, 'env.types.ts')
    await fs.writeFile(typesPath, this.generateTypes())
    
    // Write global declarations file
    const globalTypesPath = path.join(outputDir, 'env.d.ts')
    await fs.writeFile(globalTypesPath, this.generateGlobalTypes())
  }

  private getTypeScriptType(varConfig: ProjectVariableConfig): string {
    switch (varConfig.type) {
      case 'number':
        return 'number'
      case 'boolean':
        return 'boolean'
      case 'port':
        return 'number'
      case 'json':
        return 'Record<string, any>'
      case 'url':
      case 'email':
      case 'path':
      case 'string':
      default:
        return 'string'
    }
  }

  private formatValue(value: string, varConfig: ProjectVariableConfig): string {
    switch (varConfig.type) {
      case 'number':
      case 'port':
        return value || '0'
      case 'boolean':
        return value === 'true' ? 'true' : 'false'
      case 'json':
        try {
          return JSON.stringify(JSON.parse(value))
        } catch {
          return '{}'
        }
      default:
        return `"${value || ''}"`
    }
  }

  private toPascalCase(str: string): string {
    return str
      .split(/[-_\s]+/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
  }

  /**
   * Determine if a variable is a client-side variable based on common patterns
   */
  private isClientVariable(name: string): boolean {
    // Common patterns for client variables
    const clientPatterns = [
      /^NEXT_PUBLIC_/i,
      /^VITE_/i,
      /^REACT_APP_/i,
      /^GATSBY_/i,
      /^NUXT_PUBLIC_/i,
      /^PUBLIC_/i,
      /^EXPO_PUBLIC_/i,
      /^ASTRO_PUBLIC_/i,
    ]
    
    return clientPatterns.some(pattern => pattern.test(name))
  }

  /**
   * Group variables by their group name
   */
  private groupVariables(vars: Array<{ config: ProjectVariableConfig, group: string }>): Record<string, Array<{ config: ProjectVariableConfig, group: string }>> {
    const grouped: Record<string, Array<{ config: ProjectVariableConfig, group: string }>> = {}
    
    for (const variable of vars) {
      if (!grouped[variable.group]) {
        grouped[variable.group] = []
      }
      grouped[variable.group].push(variable)
    }
    
    return grouped
  }
}